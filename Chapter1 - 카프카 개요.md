# Chapter1 - 카프카 개요

## 목차

- 잘란도와 트위터의 카프카 도입 사례
- 국내외 카프카 이용 현황
- 카프카의 주요 특징
- 카프카의 성장
- 다양한 카프카의 사용 사례
- 정리

## 잘란도와 트위터의 카프카 도입 사례

두 기업의 카프카 사용 사례로 카프카 도입의 당위성과 도입으로 얻을 수 있는 장점을 파악해보자.

### 잘란도

잘란도는 독일의 온라인 패션 플랫폼 기업으로, 회사와 프로젝트의 규모가 커짐에 따라 여러 시도들을 하게 된다.

**이벤트 드리븐 시스템 도입**

특징

- 데이터의 변화가 스트림으로 컨슈머 측에 전달된다. 컨슈머들은 자신의 요구사항에 따라 데이터를 처리하거나 구독할 수 있게 되었다.

이슈

- 인바운드 데이터와 아웃바운드 데이터가 동일해야하는데, 이를 검증하는 것이 피로도가 매우 높아졌다.

**REST API 설계**

고민 포인트

- 데이터 파이프라인을 통해 들어온 데이터가 저장될 때 정합성과 이벤트들의 변경 순서 보장하는지
- 그리고 이벤트들이 효율적으로 클라이언트에 전달되는지

**API + PostgreSQL로 CRUD 구성의 한계**

- 여러 네트워크 환경에서 모든 데이터 변경에 대한 올바른 전달 보장 문제
- 동일한 데이터를 동시에 수정하면서 정확하게 순서를 보장해야함. 수정된 이벤트들을 정확한 순서대로 아웃바운드 전송도 해야함.
- 다양한 클라이언트들의 요구사항을 효율적으로 지원하기 어려움
- 빠른 전송을 위한 클라이언트 또는 대량 배치 전송을 위한 클라이언트 지원이 어려움

결국 비동기 방식의 스트리밍 플랫폼 카프카를 도입하게 된다.

**카프카를 선택한 이유**

- 높은 처리량
- 순서 보장
- 적어도 한 번(at least once) 전송 방식
- 강력한 파티셔닝
- 자연스러운 백프레셔 핸들링
- 로그 컴팩션

좀 더 자세히 보면

- 높은 처리량
    - 이벤트가 카프카로 처리되는 응답시간은 한 자릿수의 밀리초(ms)
    - 빠르고 안전하기 까지
- 순서 보장
    - 이벤트 처리 순서가 보장되면서, 유효성 검사나 동시 수정 같은 복잡성이 제거
    - 그러 인해 구조가 매우 간결해짐
- 적어도 한 번(at least once) 전송 방식
    - 멱등성: 동시에 작업을 여러 번 수행하더라도, 결과가 달라지지 않음)
    - 간혹 이벤트가 중복 발생할 수 있지만, 누락 없는 재전송이 가능. 백엔드에서 중복 메시지 처리가 가능하다면 복잡한 트랜재션 처리가 필요하지 않음.
- 백프레셔 핸들링
    - 클라이언트는 풀 방식으로 동작하므로, 클라이언트의 속도로 데이터를 처리할 수 있고, 푸시 방식처럼 브로커의 속도에 의존하지 않음.
- 파티셔닝
    - 토픽을 여러 개로 나눌 수 있다. 파티션들은 다른 파티션들과 관계없이 처리될 수 있음
- 그 외
    - 로그 컴팩션
        - 스냅샷이 가능해져서 나중에 메시지를 읽어가도 문제가 발생하지 않음
        프로듀서, 컨슈머가 완벽 분리된 비동기 방식
        - 애플리케이션의 병목 파악이 쉽고, 모니터링으로 지연 문제를 빠르게 확인 가능

이후 잘란도는 자동화된 데이터 중심의 방법론을 구현하는데 카프카를 이용했고, 실시간 도메인 랭킹을 수행하는데 카프카 스트림즈를 이용했다.
(카프카 스트림즈는 맴리듀스 스타일 연산에 필요한 기본 요소를 가추었고, 실시간 처리가 가능하다)

카프카를 더욱 적극 도입을 한 이후로 서비스 품질이 크게 향상되었다.
--> 기업 성장과 방향성에도 영향을 줄 만큼 강력하다.

### 트위터

카프카 초기 버전을 도입했으나 불안정성이 있어서 다른 시스템을 쓰다가, 카프카 다시 전환한다.
전환 목적으로 **비용 절감**과 **커뮤니티** 두 가지 측면들이 검토되었다.

**비용절감 효과**

기존에 쓰던 이벤트 버스와 성능 비교를 해보니 처리량과 관련없이 카프카가 응답 속도가 빨랐다.

![image](https://user-images.githubusercontent.com/58337059/195571258-72d3ec5f-35c0-4916-8fd7-01a84664eef9.png)

성능 차이를 보이는 이유

- 이벤트 버스는 서빙, 스토리지 레이어가 분리되어 있어서 추가적인 홉이 필요하지만, 카프카는 하나의 프로세스에서 스토리지와 요청을 모두 처리한다.
- 이벤트 버스는 fsync()를 하는 동안 블로킹하는 반면, 카프카는 OS에 의존해 백그라운드로 fsync()를 처리하고 제로카피를 사용했다.

결과적으로 카프카 사용이 60~70%의 하드웨어 리소스 절감 효과를 주었다.

**강력한 커뮤니티**

카프카는 오픈소스 프로젝트라 이슈가 발생했을 때 검색으로 해결 방법을 찾기가 쉽다.
그리고 카프카가 대중화되어 새로운 데이터 엔지니어를 고용하기 쉽다.

-> 기술적인 성능 개선, 비용 절감, 인력 충원 효과 의 장점이 있다.

아래 이슈가 있다면 카프카를 고려해보자

- 동기 / 비동기 데이터 전송에 대한 고민이 있는가?
- 실시간 데이터 처리에 대한 고민이 있는가?
- 현재의 데이터 처리에 한계를 느끼는가?
- 새로운 데이터 파이프라인이 복잡하다고 느끼는가?
- 데이터처리의 비용 절감을 고려하고 있는가?

## 국내외 카프카 이용 현황

해외

- 라인: 50여 개 서비스에서 이용
- 뉴욕타임즈: 스트림즈로 실시간 콘텐츠 배포
- 아디다스: 데이터 소스 시스템을 통합하고, 모니터링과 분석 작업을 실시간으로 처리.
- 데이터독: 메트릭, 이벤트 통합 파이프라인으로 이용
- 스포티파이: 로그 전송 시스템으로 이용

국내

- 네이버, 카카오 등

## 카프카의 주요 특징

- **높은 처리량과 낮은 지연시간**

![image](https://user-images.githubusercontent.com/58337059/195571414-2fa2a08e-69ad-48c1-b9ca-14302be2b29e.png)

다른 메시징 시스템과 비교해 보았을 때, 카프카가 처리량이 가장 높고, 래빗MQ가 응답속도가 가장 빠르다.
종합적으로 보면 카프카의 성능이 독보적이다.

- **높은 확장성**
아무리 성능이 좋아도 한계가 있으므로 확장이 가능해야하는데, 카프카는 손쉬운 확장이 가능하다.
- **고가용성**
리플리케이션 기능 추가로 카프카 클러스터의 고가용성 확보되었다.
- **내구성**
    - 카프카 프로듀서의 acks라는 옵션을 조정하여 메시지의 내구성을 강화할 수 있다. 강력한 메시지 내구성을 원한다면, 옵션을 acks=all로 사용하면 된다.
    - 카프카로 전송되는 모든 메시지가 카프카의 로컬 디스크에 저장되고, 컨슈머가 메시지를 가져가도 삭제되지 않는다. 메시지는 지정된 설정 시간이나 로그 크기만큼 디스크에 보관되므로, 코드 버그나 장애 발생 시 과거 메시지들로 재처리가 가능하다.
    (이 부분은 전통적인 메시징 시스템에서 컨슈머가 메시지를 가져감과 동시에 저장소에서 메시지가 삭제되는 것과 비교되는 포인트)
    - 메시지가 브로커 여러대에 저장되므로, 장애가 발생해도 다른 브로커의 로컬디스크로 복구가 가능
- **개발 편의성**
프로듀서와 컨슈머가 완벽히 분리되어 동작하고 서로 영향을 주지 않는다.
또 개발 편의성을 위해 카프카 커넥트, 스키마 레지스트리 제공한다.
    - 스키마 레지스트리: 데이터를 파싱하는 데 발생하는 비효율을 개선하고 등장. 스키마를 정의해서 사용
    - 카프카 커넥트: 프로듀서와 컨슈머를 따로 개발할 필요없이 카프카와 연동해 소스와 싱크로 데이터를 보내고 받을 수 있음. 엘라스틱서치, HDFS 등 여러 소스와 싱크 제공
    - 카프카 클러스터 + 카프카 커넥트로 효율적인 장애 대응과 서비스 품질 개선이 가능하다.
- **운영 및 관리 편의성**
위의 훌륭한 장점들로 인해 중앙 메인 데이터 파이프라인을 두는 것이 가능하다. 증설 작업과 최신 버전 무중단 업그레이드가 간단하게 가능하다.

## 카프카의 성장

![image](https://user-images.githubusercontent.com/58337059/195571493-a29baf8d-0659-463e-9179-2c7728920ce2.png)

- v0.8: 리플리케이션 기능 추가
- v0.8.2: 스키마 레지스트리 공개
    - 고급 인력이 데이터를 분석하거나, 비정형 데이터를 파싱하는데 많은 시간을 소모하는 것을 해결 가능하게 해주었다.
- v0.9: 카프카 커넥트 공개
    - 카프카와 연동 가능한 DB와 프로토콜이 늘어나면서 발생한 유지보수의 어려움을 해결하기 위해 등장하였고, 별도의 코드 작성 없이 카프카와 연동할 수 있게 되었다.
- v0.10: 카프카 스트림즈 공개
    - 가벼운 클라이언트로 실시간 분석과 처리가 가능해졌다.
- KSQL 공개: 익숙한 SQL 사용가능해졌다. KSQL로 배치 처리도 가능하다.
- v3.0: 주키퍼 의존성 제거

## 다양한 카프카의 사용 사례

이제는 기업들이 단순하게 pub/sub 모델 뿐만 아니라 데이터 통합, 메시지 버스, 실시간 데이터 처리, 실시간 데이터 분석 등에 카프카와 에코시스템을 사용한다.

- 데이터 파이프라인: 넷플릭스

![image](https://user-images.githubusercontent.com/58337059/195571574-9d49b467-d7fe-4da0-83b0-2f09050f202c.png)

데이터를 수집, 통계, 처리, 적재를 위한 파이프라인 연결에 카프카를 사용한다.
사용자의 넷플릭스 비디오 시청 활동, 유저 인터페이스 사용 빈도, 에러 로그 등이 데이터 파이프라인을 흐른다.
이런 내용을 분석해 사용자의 경험을 예측해 능동적으로 대응하고, 오류 발생을 실시간으로 대응한다.

- 데이터 통합: 우버

![image](https://user-images.githubusercontent.com/58337059/195571628-c70bf4ec-406b-4f3a-8edc-3ac1925aabac.png)

모든 데이터가 카프카를 통해 오가는 구조로, 운전자와 탑승자 앱으로부터 이벤트 데이터를 수집하고 실시간, 배치 파이프라인으로 구분해서 다양한 다운스트림 컨슈머에 전달한다. 애플리케이션 분석, 디버깅, 알람 등에 이용되었다.

- 람다 아키텍처
    - 데이터 처리 중 배치, 실시간 파이프라인이 있는 아키텍처
    - 배치, 실시간 처리의 다른 요구사항으로 인한 구조의 복잡성이 있어 개선안으로 카파(Kappa) 아키텍처가 제안되었다.
- 머신러닝 분야: 컨플루언트에서 공개한 사례

![image](https://user-images.githubusercontent.com/58337059/195571662-b09097e2-93bf-47f9-86cf-39b1156b9644.png)

데이터 전송과 파이프라인을 위해 카프카 커넥트를, 모델 생성과 상용 머신러닝 앱의 실시간 처리를 위해 카프카 스트림즈를 사용했다. 그 외 스키마 레지스트리, KSQL 등이 종합적으로 사용되었다.

- 스마트 시티 분야 활용 사례

![image](https://user-images.githubusercontent.com/58337059/195571712-1875ce2e-c49b-48d6-99b2-00f32c51b85c.png)

스마트 시티는 여러 형태의 IoT 데이터를 수집해 이를 바탕으로 자산, 리소스, 서비스의 운용 효율을 높인다. 도시 규모로 발생되는 모든 데이터를 수집하고 분석하는데 사용된다. 스마트 시티에서 수집하는 데이터 양은 워낙에 방대하기에 카프카를 필수적으로 사용할 수 밖에 없다. 

- 도시마다 카프카로 데이터를 수집한다.
- 카프카와 카프카 사이 안정적인 데이터 전송에 카프카 커넥트를 사용한다.
- 사전에 정의된 스키마를 이용해 데이터 변화 등에 유연하게 대응하기 위해 스키마 레지스트리를 사용한다.

## 결론

카프카는 실시간 데이터 플랫폼 또는 이벤트 스트리밍 플랫폼이라 불리고, 모든 데이터 처리 프로세싱의 핵심이다.
