# 6.1 컨슈머 오프셋 관리

- 컨슈머가 메시지를 어디까지 가져왔는지 표기 하는 것이 중요 ⇒ **오프셋**
    - 코드 배포로 인해 컨슈머가 일시적으로 동작을 멈추고 재시작 하는 경우
    - 컨슈머가 구동중인 서버에서 문제가 발생해 새로운 컨슈머가 기존 컨슈머의 역할을 대신하는 경우
    
    → **기존 컨슈머의** **마지막 메시지 위치**부터 **새로운 컨슈머가 메시지를 가져올 수** 있어야 장애 복구가 빠름
    

## 오프셋

- 메시지의 위치를 나타내는 위치
- 숫자로 표현
- **컨슈머 그룹**은 자신의 **오프셋 정보**를 **토픽**에 저장 (내부 토픽)
    - **`_consumer_offsets` 토픽**에 각 컨슈머 그룹별로 오프셋 위치 정보가 기록 됨

## 컨슈머 기본 동작

1. 컨슈머들이 지정된 토픽의 메시지를 읽은 후, `읽어온 위치 정보`를 **_consumer_offsets 토픽**에 기록
2. 컨슈머 그룹은 `컨슈머 그룹`, `토픽`, `파티션` 등의 내용을 통합해서 기록
3. _consumer_offsets 에 기록된 정보를 이용해 컨슈머 그룹은 자신의 그룹이 속해 있는 컨슈머의 변경이 발생되는 경우 해당 컨슈머가 어느 위치까지 읽었는지를 추적 할 수 있음
    - 여기서 저장되는 오프셋 값은 컨슈머가 다음으로 읽어야 할 위치
- **_consumer_offsets**
    - 다음과 같은 파티션 수와 리플리케이션 팩터 수를 가지고 있음
        - offsets.topic.num.partitions : 기본 값 50
        - offsets.topic.num.replication.factor : 기본값 3
    - 내부 토픽이지만 파티션수와 리플리케이션 팩터수는 설정파일인 `server.properties`에서 관리자가 원하는 값으로 변경 가능

# 6.2 그룹 코디네이터

- 컨슈머들은 하나의 컨슈머 그룹의 구성원
- 컨슈머 그룹 내의 각 컨슈머들은 서로 자신의 정보를 공유하며 하나의 공동체로 동작 함
- 컨슈머 그룹 내 컨슈머들은 합류하거나 떠날 수 있음
    - 변화 인지 및 작업 균등 분배 필요 ⇒ **컨슈머 리밸런싱**

### 컨슈머 리밸런싱

- 컨슈머 그룹에서 각 컨슈머들에게 작업을 **균등하게 분배**하는 동작

### 그룹 코디네이터

- **안정적인 컨슈머 그룹** **관리**를 위해 존재하는 코디네이터
- 목적
    - 컨슈머 그룹이 구독한 토픽의 파티션들과 그룹의 멤버들을 트래킹 하는 것
- 그룹 멤버의 변화가 생기면 작업을 균등하게 재분배 하기 위해 컨슈머 리밸런싱 동작 발생
- 그룹 코디네이터는 컨슈머 그룹 별로 존재
- 카프카 클러스터 내의 브로커 중 하나에 위치
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9c52bc61-a565-4b89-826e-da125b6be406/Untitled.png)
    
    - 컨슈머 그룹이 브로커에 최초 연결 요청을 보냄
    - 브로커 중 하나에 그룹 코디네이터가 생성 됨
        - 이 코디네이터는 컨슈머 그룹의 컨슈머 변경과 구독하는 토픽 파티션 변경 등에 대한 감지 시작
        - 토픽의 파티션과 그룹의 맴버 변경이 일어나면 변경된 내용을 컨슈머들에게 알려줌
## 컨슈머 그룹과 그룹 코디네이터의 동작 과정

![IMG_1210.heic](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0d9582f8-a23c-4d66-a090-6c29eca5fd72/IMG_1210.heic)

1. 컨슈머는 컨슈머 설정 값 중 bootstrap.brokers 리스트에 있는 브로커에게 컨슈머 클라이언트 **초기 커넥션을 연결하기 위한 요청**을 보냄
2. 요청을 받은 **브로커**는 그룹 코디네이터를 생성하고, **컨슈머에게 응답**을 보냄.
컨슈머 그룹의 첫번째 컨슈머가 등록될 때까지 아무 작업도 일어나지 않음
3. **그룹 코디네이터**는 `group.initial.rebalance.delay.ms`시간동안 컨슈머의 **요청을 기다림**
4. **컨슈머**는 컨슈머 등록 요청을 **그룹 코디네이터**에게 보냄
이때 가장 먼저 요청을 보내는 컨슈머가 컨슈머 그룹의 리더가 됨
5. 컨슈머 등록 요청을 받은 그룹 코디네이터는 **해당 컨슈머 그룹이 구독하는 토픽 파티션 리스트 등** **리더 컨슈머의 요청에 응답**을 보냄
6. **리더 컨슈머**는 정해진 컨슈머 파티션 할당 전략에 따라 **그룹 내 컨슈머들에게 파티션을 할당**한 뒤 **그룹 코디네이터에게 전달**
7. **그룹 코디네이터는 해당 정보를 캐시**하고 각 **그룹 내 컨슈머들에게 성공**을 알림
8. 각 컨슈머들은 **각자 지정된 토픽 파티션으로부터 메시지들을 가져옴**

- 컨슈머 그룹과 그룹 코디네이터가 서로 은밀하게 내용을 주고 받으며 컨슈머 그룹이 안정적으로 메시지를 읽어갈 수 있도록 유지하기 위해 노력함
- **컨슈머 그룹의 변화**들은 컨슈머 코디네이터에게 컨슈머가 `join` 또는 `leave`요청을 보냄으로써 자연스럽게 처리 됨
    - 하지만 장애로 정상적으로 종료가 되지 않는다면? → 하트비트로 감지
- 하트비트
    - 컨슈머들의 변경을 감지 하기 위해 **그룹 코디네이터** ←→ **컨슈머**들은 **하트비트**를 주고 받음
    - 주기적으로 주고 받으며 살아있는지, 잘 동작하는지 확인
    - 하트비트 옵션
        - 
- 그룹 코디네이터는 하트비트로 컨슈머 상태 확인 및 문제시 컨슈머 리밸런싱 동작 수행
    - 파티션에서 컨슈머가 정삭적으로 메시지를 가져가는 지는 `poll() 동작` 여부를 통해 확인
- 가급적 리벨런싱이 자주 발생하지 않는 것 권장 ⇒ 되도록 기본 값 유지
    - 다운을 빠르게 감지하도록 설정 시
        - 원하지 않는 리밸런싱이 빈번하게 일어나는 현상 발생
    - 다운을 늦게 감지하도록 설정 시
        - 그 시간만큼 해당 파티션의 메시지를 읽지 못함
        
# 6.3 스태틱 멤버십

- 컨슈머 그룹 내 컨슈머들을 하나씩 순차적으로 재시작 하고 싶음
    - 하지만, 하트비트 주기나 세션 타임아웃 등의 설정으로 인해 하나의 컨슈머가 재시작 될 때마다 전체 리밸런싱 & 리밸런싱이 일어나는 동안 컨슈머들은 일시 정지 상태가 됨
- 왜 컨슈머의 재시작으로 리밸런싱이 일어나는가?
    - 일반적인 컨슈머 그룹 동작에서는 각 컨슈머를 식별하기 위해 `엔티티 ID`를 부여
    - 이렇게 생성된 ID들은 컨슈머 그룹내에서 **임시로 사용**하는 값
    - 컨슈머가 재시작 → 컨슈머 그룹 내의 동일한 컨슈머임에도 **새로운 컨슈머로 인식**
        - ⇒ **새로운 엔티티 ID 부여 됨**
        - ⇒ 컨슈머 리벨런싱 발생

## 스태틱 맴버십

- 컨슈머마다 인식할수 있는 ID 적용해서 그룹에서 나갔다 다시 합류하더라도 기존 구성원임을 그룹 코디네이터가 알수 있게 함
- 이 기능이 적용된 컨슈머는 그룹에 떠날 때 그룹 코디네이터에게 알리지 않음 → 불필요한 리밸런싱 피함

- 스태틱 맴버십이 적용되지 않은 경우
    1. 떠날 때 리벨런싱
    2. 합류할 때 리벨런싱

- 스태틱 맴버십이 적용된 경우
    1. 떠날 때 리벨런싱 안함
    2. 합류할 때 기존 구성원으로 인식해서 리벨런싱 안함

→ 총 두번의 리벨런싱 피함

- 스태틱 맴버십을 적용하기 위한 옵션
    - null string인 `group.instance.id` 설정 → 카프카 2.3 이상
    - `group.instance.id` 에는 고유한 값 입력
- 스태틱 맴버십을 적용할 때 `session.timeout.ms`를 기본값보다 큰 값으로 조정
    - 여기에 지정된 시간만큼 하트비트 못받으면 강제 리밸런싱 일어나기 때문


# 6.4 컨슈머 파티션 할당 전략

- 파티셔너
    - 레코드를 토픽의 어느 파티션으로 전송할지를 결정하는 역할
    - 컨슈머에서도 이와 비슷하게 대상 토픽의 어느 파티션으로 레코드를 읽어 올지 결정
    - 컨슈머 그룹 리더가 각 컨슈머와 대상 토픽의 파티션을 매칭
- 컨슈머 옵션 partition.assignment.stratage
    1. RangeAssignor
        - 기본 값
        - 토픽별로 할당 전략 사용
        - 동일한 키를 이용하는 2개 이상의 토픽을 컨슘할 때 유용
    2. RoundRobinAssignor
        - 라운드로빈으로 할당
        - 균등한 분배
    3. StickyAssignor
        - 컨슈머가 컨슘하고 있는 파티션을 계속 유지 가능
    4. CooperativeStickyAssignor
        - 스티키 방식과 비슷하지만 연속적 재조정 방식

### 1. 레인지 파티션 할당 전략

- 각 토픽별로 할당 전략 사용
- 구독하는 토픽에 대한 파티션을 순서대로 나열 → 컨슈머를 순서대로 정렬
- 그 후 각 컨슈머가 몇개의 파티션을 할당해야 하는지 전체 파티션 수를 컨슈머 수로 나눔
- 균등하게 나눠지지 않는 경우는 앞쪽의 컨슈머들은 추가 파티션 할당 받음
- 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1809f352-65ee-4cef-b48e-df3d144ec4e5/Untitled.png)
    
    - 토픽 1의 파티션 0,1,2 를 정렬 & 컨슈머 1, 2 정렬
    - 3 / 2 를 하면 1이므로 각 컨슈머에 파티션을 하나씩 할당
    - 나머지가 1이므로 컨슈머 1에 파티션 하나 더 할당
    - 즉, 파티션 0,1 은 컨슈머 1에, 파티션 2는 컨슈머 2에 매핑 됨
- 위와 같이 불균형하게 할당 될 수 있음
- 동일한 레코드 (메시지) 키를 사용하고 하나의 컨슈머 그룹이 동일한 파티션 수를 가진 2개 이상의 토픽을 컨슘할 때 유용
    - 동일한 키 값을 가지고 있는 두 토픽의 파티션을 하나의 컨슈머가 컨슘할 수 있음

### 2. 라운드 로빈 파티션 할당 전략

- 파티션을과 컨슈머를 순서대로 나열후 라운드 로빈으로 하나씩 컨슈머를 할당

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e8a3efd-e332-472e-add4-04e47afdde45/Untitled.png)

- 하나씩 번갈아가면서 컨슈머를 할당
- 균등하게 매핑 됨

### 3. 스티키 파티션 할당 전략

- 리밸런싱 동작으로 파티션이 재할당?
    - 기존에 매핑됐던 파티션과 동일한 컨슈머가 매핑되는 것 보장 못함
- 기존에 매핑됐던 파티션과 컨슈머를 최대한 유지 하려는 전략
- 목적
    1. 가능한 한 균형 잡힌 파티션 할당
    2. 재할당이 발생할 때 되도록 기존의 할당된 파티션 정보 보장
- 최초 할당 전략
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8febe1a-17d1-4efe-8371-35949b2bb34a/Untitled.png)
    
- **라운드 로빈**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6c3d4f97-0163-49cd-88cc-2938daf04095/Untitled.png)
    
    1. 컨슈머 2가 컨슈머 그룹을 떠남
    2. 리밸런싱 동작
    3. 모든 파티션을 순서대로 배치
    4. 모든 컨슈머를 순서대로 배치
    5. 라운드 로빈 파티션 할당 전략에 맞춰 하나씩 매핑
5. 
- **스티키 파티션 할당 전략**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bd34afe2-8098-4611-a253-b7c300ff3824/Untitled.png)
    
    - 기존 컨슈머들이랑 연결된 파티션들은 모두 유지하고, 컨슈머 2에 할당된 파티션들만 재배치
    - 규칙
        - 컨슈머들의 최대 할당된 파티션 수 차이는 1
        - 기존에 존재하는 파티션 할당은 최대한 유지
        - 재할당 동작시 유호하지 않은 모든 파티션 할당은 제거
        - 할당되지 않은 파티션들은 균형을 맞추는 방법으로 컨슈머들에 할당

### 일반적인 리밸런싱 동작

- 컨슈머 그룹 내부의 리밸런싱 동작이 한층 더 고도화 됨
- 지금까지의 컨슈머 리밸런싱 동작 : `EAGER 리밸런싱 프로토콜` 사용
    - 컨슈머 리밸런싱 동작 시 컨슈머에 할당된 모든 파티션을 항상 취소
    - 이유
        1. 컨슈머들의 소유권 변경
            - 하나의 컨슈머 그룹내에서는 둘 이상의 컨슈머가 동일한- 파티션 소유 X
        2. 그룹 내에서 여러 파티션들에 대해 소유권 변경 작업이 동시에 이루어져야 하므로 이를 단순하게 구현하기 위함
- **컨슈머 다운 타임** - 컨슈머가 다운되어있는 시간
    - 리소스를 많이 사용하는 컨슈머 그룹에서는 큰 문제
- **일반적인 리밸런싱 동작 과정**
    - 감지, 중지, 재시작
    1. 감지
        1. peter-kafka02 컨슈머가 다운 됨을 감지
    2. 중지
        1. 컨슈머에게 할당된 모든 파티션 제거
        2. 컨슈머의 다운 타임 시작 ( 컨슈머에게 할당된 파티션이 없으므로)
        3. 이때 프로듀서는 해당 토픽을 타겟으로 지속적으로 메시지 전송 중임
            - LAG급격히 증가중
    3. 재시작
        1. 구독한 파티션 재할당
        2. 컨슈머 다운 타임 종료
    - 스태틱 맴버십을 사용하더라도 여전히 컨슈머 다운 타임은 존재

### 협력적 스티키 파티션 전략

- `COOPERATIVE 프로토콜` 사용
    - 리밸런싱이 동작하기 전의 컨슈머 상태를 유지할 수 있게 함
- 되도록 동작중인 컨슈머들에게 영향을 주지 않는 상태에서 몇 차례 걸쳐서 리밸런싱
- 안전하게 파티션의 소유권을 이동하기 위해 리밸런싱 작업이 수차례 걸쳐 진행
- **동작**
    1. 컨슈머 그룹에 peter-kafka01이 합류하면서 **리밸런싱 트리거**
    2. 컨슈머 그룹 내 컨슈머들은 **그룹 합류 요청**과 **자신들이 컨슘하는 토픽의 파티션 정보 (소유권)를 그룹 코디네이터로 전송**
    3. 그룹 코디네이터는 해당 정보를 조합해 컨슈머 그룹의 리더에게 전송
    4. 컨슈머 그룹의 리더는 현재 컨슈머들이 소유한 파티션 정보를 활용해 **제외해야 할 파티션 정보(=파티션2)를 담은 새로운 파티션 할당 정보를 컨슈머 그룹 멤버들에게 전달**
    5. 새로운 파티션 할당 정보를 받은 컨슈머 그룹 멤버들은 현재의 **파티션 할당 전략**과 **차이**를 비교해보고 **필요 없는 파티션(파티션 0,1)은 골라 제외**
    - 이전의 파티션 할당정보와 새로운 파티션 할당정보가 동일한 파티션에 대해서는 어떤 작업도 수행할 필요가 없음
    6. **제외된 파티션 할당(=파티션2)**을 위해 컨슈머들은 다시 합류 요청
    7. 컨슈머 그룹의 리더는 **제외된 파티션**을 적절한 컨슈머에게 할당

# 6.5 정확히 한 번 컨슈머 동작

### **프로듀서**

- 프로듀서의 정확히 한번 전송 동작을 위해 → 브로커 측에는 **전체 트랜잭션 관리 & 프로듀서 동작을 보조**하는 **트랜잭션 코디네이터** 존재
- **트랜잭션 코디네이터**
    - 프로듀서의 정확히 한번 전송을 성공하면 
    → 해당 레코드의 트랜잭션 성공을 표시하는 특수 메시지 추가
- 트랜잭션 코디네이터가 특수한 메시지를 표시한 레코드만 읽는다면 정확히 한 번 읽을 수 있음.

### **컨슈머**

- 일반 컨슈머 코드에서 `ISOLATIOON_LEVEL_CONFIG` 설정을 추가하면 **트랜잭션 컨슈머**로 동작
    - read_uncommited
        - 모든 메시지를 읽을 수 있음
    - read_commited
        - 트랜잭션이 완료된 메시지만 읽을 수 있음
- 트랜잭션 컨슈머는 트랜잭션 코디네이터와 통신하진 않음
    - → 트랙잭션이 완료된 메시지만 읽을 수 있음
